<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>Domanda o Verità – Azione</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="style.css?v=1_0_0">
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <script src="firebase-config.js?v=1_0_0"></script>
  <script src="firebase-init.js?v=1_0_0"></script>
  <script src="common.js?v=1_0_0"></script>
  <style>.countdown{font-weight:700;} .muted{opacity:.8}</style>
</head>
<body>
  <div class="version">MVP v1.0.1c – Azione (guard & reset)</div>
  <main>
    <section class="panel">
      <h2>Fase Azione</h2>
      <div id="info" class="muted">Caricamento…</div>

      <div id="winnerGate" style="display:none">
        <p>Hai vinto la puntata. Scegli:</p>
        <div class="row">
          <button id="btnAsk" class="bigBtn">Domanda</button>
          <button id="btnTruth" class="secondary bigBtn" disabled title="In sviluppo">Verità</button>
        </div>
        <div id="askUI" style="display:none; margin-top:12px">
          <p>Tempo per inviare la domanda: <span id="qTimer" class="countdown">60</span>s</p>
          <label for="qSelect"><strong>Domanda</strong></label>
          <select id="qSelect">
            <option value=""></option>
            <optgroup label="SUM – Somma">
              <option value="SUM_POS3">Scegli 3 posizioni. Somma dei valori su quelle carte?</option>
              <option value="SUM_SUIT">Scegli un seme. Somma dei valori su quel seme?</option>
            </optgroup>
            <optgroup label="COUNT – Conteggio">
              <option value="COUNT_FACES">Quante carte figura ha l'avversario?</option>
              <option value="COUNT_NUMS">Quante carte numeriche ha l'avversario?</option>
              <option value="COUNT_CHOOSE">Quante del tipo scelto (figura/numerica)?</option>
            </optgroup>
            <optgroup label="POSITION – (coming soon)">
              <option disabled>Posizioni di un seme</option>
              <option disabled>Posizioni con stesso valore</option>
              <option disabled>Posizioni con valori consecutivi</option>
              <option disabled>Posizione del massimo/minimo</option>
            </optgroup>
          </select>
          <div id="qParams" class="qform" style="display:none"></div>
          <div class="row">
            <button id="sendQ" class="bigBtn" disabled>Invia domanda</button>
          </div>
          <div class="muted">Se scade il tempo, il turno viene sprecato e si passa automaticamente alla puntata successiva.</div>
        </div>
      </div>

      <div id="loserGate" style="display:none">
        <p>L'avversario sta scegliendo la domanda… Tempo residuo: <span id="qTimer2" class="countdown">60</span>s</p>
      </div>

      <div id="qaReveal" class="panel" style="display:none">
        <h3>Esito Domanda</h3>
        <p id="qText"></p>
        <p id="aText" class="badge"></p>
        <p class="muted">Nuovo turno tra <span id="revealTimer" class="countdown">20</span>s…</p>
        <div><button id="skipReveal" class="secondary">Vai subito al prossimo turno</button></div>
      </div>
    </section>
  </main>

  <script>
  (function(){
    const {qs, params} = DV;
    const gid=params().get('game'); const role=params().get('role');
    const info=qs('#info');
    const winnerGate=qs('#winnerGate'); const loserGate=qs('#loserGate');
    const btnAsk=qs('#btnAsk');
    const askUI=qs('#askUI'); const qSelect=qs('#qSelect'); const qParams=qs('#qParams'); const sendQ=qs('#sendQ');
    const qTimer=qs('#qTimer'); const qTimer2=qs('#qTimer2');
    const qaReveal=qs('#qaReveal'); const qText=qs('#qText'); const aText=qs('#aText'); const revealTimer=qs('#revealTimer'); const skipReveal=qs('#skipReveal');
    let qTicker=null, qDeadline=null;

    function cardValue(code){
      const rank = code.replace(/[pcqf]$/,'').toUpperCase();
      if(['A','J','Q','K'].includes(rank)) return 10;
      const n = parseInt(rank,10); return isNaN(n)?0:n;
    }

    function renderParamsFor(type){
      qParams.innerHTML=''; qParams.style.display='none'; sendQ.disabled=true;
      if(type==='SUM_POS3'){
        qParams.style.display='block';
        const wrap=document.createElement('div'); wrap.className='rowcols3';
        function buildSelect(id){
          const s=document.createElement('select'); s.id=id;
          const o0=document.createElement('option'); o0.value=''; o0.textContent='Pos'; s.appendChild(o0);
          for(let i=1;i<=8;i++){ const o=document.createElement('option'); o.value=String(i); o.textContent=String(i); s.appendChild(o); }
          return s;
        }
        const s1=buildSelect('pos1'), s2=buildSelect('pos2'), s3=buildSelect('pos3');
        wrap.appendChild(s1); wrap.appendChild(s2); wrap.appendChild(s3); qParams.appendChild(wrap);
        function syncDisable(){
          const vals=[s1.value,s2.value,s3.value].filter(Boolean);
          [s1,s2,s3].forEach(sel=>{ Array.from(sel.options).forEach(o=>{
            if(!o.value) return o.disabled=false;
            o.disabled = vals.includes(o.value) && sel.value!==o.value;
          });});
          sendQ.disabled = !(s1.value && s2.value && s3.value);
        }
        s1.addEventListener('change', syncDisable); s2.addEventListener('change', syncDisable); s3.addEventListener('change', syncDisable);
      }
      if(type==='SUM_SUIT'){
        qParams.style.display='block';
        const s=document.createElement('select'); s.id='suitSel';
        s.innerHTML='<option value=""></option><option value="p">Picche (p)</option><option value="c">Cuori (c)</option><option value="q">Quadri (q)</option><option value="f">Fiori (f)</option>';
        s.addEventListener('change', ()=>{ sendQ.disabled = !s.value; });
        qParams.appendChild(s);
      }
      if(type==='COUNT_CHOOSE'){
        qParams.style.display='block';
        const s=document.createElement('select'); s.id='kindSel';
        s.innerHTML='<option value=""></option><option value="face">Figure (A,J,Q,K)</option><option value="num">Numeriche (2–10)</option>';
        s.addEventListener('change', ()=>{ sendQ.disabled = !s.value; });
        qParams.appendChild(s);
      }
      if(type==='COUNT_FACES' || type==='COUNT_NUMS'){
        sendQ.disabled=false;
      }
    }

    qSelect.addEventListener('change', ()=> renderParamsFor(qSelect.value));

    btnAsk.addEventListener('click', ()=>{
      askUI.style.display='block';
      qDeadline = Date.now()+60000;
      function draw(){ const rem=Math.max(0,Math.floor((qDeadline - Date.now())/1000)); qTimer.textContent=rem; qTimer2.textContent=rem; if(rem<=0){ clearInterval(qTicker); guardedAdvance(); } }
      if(qTicker) clearInterval(qTicker); qTicker=setInterval(draw,250); draw();
    });

    async function guardedAdvance(){
      await DB.ref('games/'+gid).transaction(data=>{
        if(!data) return data;
        if(!(data.phase==='action_reveal' || data.phase==='action')) return data;
        const curTurn = data.turn||1;
        const actTurn = data.action && data.action.turn;
        if(actTurn && actTurn!==curTurn) return data;
        if(data.postActionAdvanced) return data;
        data.postActionAdvanced = true;
        data.turn = curTurn+1;
        data.tokens_p1=(data.tokens_p1||0)+2;
        data.tokens_p2=(data.tokens_p2||0)+2;
        data.bets={};
        data.roundResolved=false;
        data.phase='betting';
        data.betDeadlineAt=Date.now()+15000;
        return data;
      });
      location.href='bet.html?game='+gid+'&role='+role;
    }

    async function submitQuestion(){
      const type=qSelect.value; if(!type) return;
      const gameSnap = await DB.ref('games/'+gid).get(); const d = gameSnap.val()||{};
      const turn = d.turn||1;
      const loserRole = (role==='p1')?'p2':'p1'; const cards = d['cards_'+loserRole] || [];
      let questionText='', answer=null;

      if(type==='SUM_POS3'){
        const p1=parseInt(qs('#pos1').value,10), p2=parseInt(qs('#pos2').value,10), p3=parseInt(qs('#pos3').value,10);
        if(!(p1&&p2&&p3)) return;
        questionText = `Somma dei valori alle posizioni ${p1}, ${p2}, ${p3} dell'avversario`;
        answer = [p1,p2,p3].reduce((acc,p)=> acc + cardValue(cards[p-1]||''), 0);
      }
      if(type==='SUM_SUIT'){
        const s=qs('#suitSel').value; if(!s) return;
        questionText = `Somma dei valori del seme ${s.toUpperCase()} dell'avversario`;
        answer = cards.filter(c=>c&&c.endsWith(s)).reduce((acc,c)=>acc+cardValue(c),0);
      }
      if(type==='COUNT_FACES'){
        questionText = 'Quante carte figura ha l\'avversario?';
        answer = cards.filter(c=>['A','J','Q','K'].includes(c.replace(/[pcqf]$/,'').toUpperCase())).length;
      }
      if(type==='COUNT_NUMS'){
        questionText = 'Quante carte numeriche ha l\'avversario?';
        answer = cards.filter(c=>{ const r=c.replace(/[pcqf]$/,'').toUpperCase(); return !['A','J','Q','K'].includes(r); }).length;
      }
      if(type==='COUNT_CHOOSE'){
        const k=qs('#kindSel').value; if(!k) return;
        questionText = (k==='face') ? 'Quante carte figura ha l\'avversario?' : 'Quante carte numeriche ha l\'avversario?';
        answer = (k==='face')
          ? cards.filter(c=>['A','J','Q','K'].includes(c.replace(/[pcqf]$/,'').toUpperCase())).length
          : cards.filter(c=>{ const r=c.replace(/[pcqf]$/,'').toUpperCase(); return !['A','J','Q','K'].includes(r); }).length;
      }

      const revealForMs=20000;
      const actionObj={ turn, by:role, type, params:{}, questionText, answer:String(answer), askedAt:Date.now(), revealUntil:Date.now()+revealForMs };
      await DB.ref('games/'+gid+'/action').set(actionObj);
      await DB.ref('games/'+gid+'/phase').set('action_reveal');
    }

    sendQ.addEventListener('click', submitQuestion);

    function showReveal(d){
      winnerGate.style.display='none'; loserGate.style.display='none'; qaReveal.style.display='block';
      const act=d.action||{};
      qText.textContent='Domanda: '+(act.questionText||'(n/a)'); aText.textContent='Risposta: '+(act.answer??'—');
      const end = (act.revealUntil && typeof act.revealUntil==='number') ? act.revealUntil : (Date.now()+20000);
      function draw(){ const rem=Math.max(0,Math.floor((end - Date.now())/1000)); revealTimer.textContent=rem; if(rem<=0){ guardedAdvance(); } }
      let it=setInterval(draw,250); draw();
      skipReveal.onclick=guardedAdvance;
    }

    DB.ref('games/'+gid).on('value', s=>{
      const d=s.val()||{}; const turn=d.turn||1; const r=d.rounds && d.rounds['turn_'+turn];
      if(d.phase==='action_reveal'){ showReveal(d); return; }
      if(d.phase!=='action'){ info.textContent='Fase non attiva (action).'; return; }
      if(!r){ info.textContent='Esito puntata non trovato.'; return; }
      if(r.winner===null){
        info.textContent='Pareggio: nessuna azione.';
        setTimeout(guardedAdvance, 1200);
        return;
      }
      const winnerRole = r.winner;
      info.textContent='Vincitore: '+(winnerRole==='p1'?(d.player1?.name||'Giocatore 1'):(d.player2?.name||'Giocatore 2'));
      if(role===winnerRole){ winnerGate.style.display='block'; loserGate.style.display='none'; }
      else { winnerGate.style.display='none'; loserGate.style.display='block'; }
    });
  })();
  </script>
</body>
</html>
